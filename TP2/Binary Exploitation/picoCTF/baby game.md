# babygame01

**Flag:** `picoCTF{gamer_m0d3_enabled_8985ce0e}`


Approach

- step 1<br>
We can reverse engineer the game using Ghidra.
In the move player() function we have two more keybinds
'l'-can be used to replace the player tile to whatever key we want.
'p'-solves the maze for us.

```
  
  if (param_2 == 'l') {
    iVar1 = getchar();
    player_tile = (undefined)iVar1;
  }
  if (param_2 == 'p') {
    solve_round(param_3,param_1);
  }

```

- step 2<br>
Now the condition in main() states the win function will not be invoked and we won't have the flag until aa4 is not NULL.
Since there is no out of bounds condition,we can write an extra integer to aa0 variable to cause a buffer underflow to change aa4's valu which is on thew same stack.
So we can go to (-4,0) coordinates and we have the flag.

```
    *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;
  return;

  if (local_aa4 != '\0') {
    puts("flage");
    win();
    fflush(_stdout)

```

- step 3<br>
Then we can use p to solve and get the flag.

![](https://github.com/adityachawla005/cryptonite_taskphase_Aditya/raw/main/TP2/Binary%20Exploitation/picoCTF/assets/b1.png)



What you learned through solving this challenge:
<br>
- How does ghidra disassemble code aand about how memory overflows and underflows occur.


Other incorrect methods you tried:
<br>
- Tried using p staright to win it but without any flag.


References
<br>
- none


<br>
<br>
<br>

# babygame02

**Flag:** `picoCTF{gamer_jump1ng_4r0unD_f35ef31a}`


Approach

- step 1<br>
We can reverse engineer the game using Ghidra.
This time we must overwrite a return address on the stack with the address of the win() function to get the flag.
First a new base pointer EBP points to the old one and we push EBX and ECX and the stack pointer is subtracted by 2720.
Now in move player function we push the map which is at -2709 bytes.Then we push EAX and local aa8.Then the return address is returned.
It adds up to a 39 byte underflow  to invoke win() function.

```
        0804967e 55              PUSH       EBP
        0804967f 89 e5           MOV        EBP,ESP
        08049681 53              PUSH       EBX
        08049682 51              PUSH       ECX
        08049683 81 ec a0        SUB        ESP,0xaa0
                 0a 00 00

```

- step 2<br>
We cannot move iteratively one step at a time as we will overwrite the previous parameters used in move_player().
Therefore the solution can be moving to y=-1 and going back 39 bytes.
We want the value of the last byte of the target address to be the same as win() return address which is 0x70 as the LSB (hex string for p).
Hence we can use lp command to to set our player position value to p.


![](https://github.com/adityachawla005/cryptonite_taskphase_Aditya/raw/main/TP2/Binary%20Exploitation/picoCTF/assets/b1.png)



What you learned through solving this challenge:
<br>
- About disassembled assembly code and how to overwrite the return address of a function without changing paramters.


Other incorrect methods you tried:
<br>
- Tried going back 39 bits resulting in overwritng paramters.


References
<br>
- none

<br>
<br>
<br>

# babygame03

**Flag:** ``


Approach

- step 1<br>
We can reverse engineer the game using Ghidra.
Like babygame01 we can create a buffer underflow for the player details to have unlimited amount of lives.
We can solve this by moving out of the grid and coming back using s after the # to prevent collision.

```
        
  int iStack_ab4;
  int iStack_ab0;
  int iStack_aac;
  undefined auStack_aa1 [2700];
  char cStack_15;
  int iStack_14;
  undefined *puStack_10;

```

- step 2<br>
Like babygame02 we make to use of return address with an offset of -51 bytes and y=1.We can use lp command and we get to level 5.
Similarly we make use of return address for 0xfe.




What you learned through solving this challenge:
<br>
- About disassembled assembly code and how to overwrite the return address of a function without changing paramters.


Other incorrect methods you tried:
<br>
- none


References
<br>
- none



